{"version":3,"sources":["fps.js","mode_selector.js","input.js","../node_modules/shuffle-array/index.js","game.js","app.js"],"names":["fpsUpdateDelay","updateFps","t","Math","round","renderFps","ctx","fps","fillStyle","fillRect","font","fillText","ModeSelector","select","events","mode","init","addEventListener","value","push","input","keyMap","el","event","keyCode","queue","getWrapX","GRID_WIDTH","wrapX","x","getDoesCollide","piece","grid","shape","collides","forEach","line","y","block","_y","pieces","i","z","s","o","l","j","spawn","getNext","length","pieceTypes","Object","keys","grid2","SCREEN_WIDTH","SCREEN_HEIGHT","GRID_HEIGHT","VOID_RADIUS","CRUST_THICKNESS","SCREEN_CENTRE","ACTIVE_RADIUS","circleRadius","circle","bottom","w","modeSelector","selectMode","type","angle","doesCollide","Array","fill","map","r","gridLookup","getGridCoords","radius","floor","PI","renderGrid","pixelHeight","hue","dotX","xCentre","yCentre","dx","dy","sqrt","getAngle","gridX","gridY","fuzz","random","shock","hue2","getClickHandler","e","timestamp","startedAt","rect","target","getBoundingClientRect","clientX","left","clientY","top","scale","width","halfPi","atan","start","shockDecay","processEvent","console","log","speed","update","shift","max","slice","cell","render","window","performance","now","Date","last","step","undefined","min","requestAnimationFrame","view","setAttribute","getContext","document"],"mappings":"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","file":"app.cb27e058.js","sourceRoot":"..\\src","sourcesContent":["let fpsUpdateDelay = 0;\r\n\r\nexport function updateFps(t) {\r\n  fpsUpdateDelay += t;\r\n  if (fpsUpdateDelay > 1000) {\r\n    fpsUpdateDelay = 0;\r\n    return Math.round(1 / (t / 1000));\r\n  }\r\n}\r\n\r\n\r\nexport function renderFps(ctx, fps) {\r\n  // Draw number to the screen\r\n  ctx.fillStyle = \"#333\";\r\n  ctx.fillRect(0, 0, 80, 32);\r\n  ctx.font = \"14px Arial\";\r\n  ctx.fillStyle = \"#CCC\";\r\n  ctx.fillText(\"FPS: \" + fps, 10, 20);\r\n}\r\n","export default function ModeSelector(select, events) {\r\n  this.mode = \"normal\";\r\n  this.init = () => {\r\n    select.addEventListener(\"change\", () => {\r\n      this.mode = select.value;\r\n      if (select.value === 'nuts') {\r\n        events.push('go nuts');\r\n      }\r\n    })\r\n    select.value = 'normal';\r\n    \r\n  }\r\n}\r\n","const keyMap = {\r\n  37: 'left',\r\n  38: 'up',\r\n  39: 'right',\r\n  40: 'down',\r\n};\r\n\r\nconst input = {\r\n  init: (el, events) => {\r\n    el.addEventListener(\"keydown\", (event) => {\r\n      const value = keyMap[event.keyCode];\r\n      if (value) events.push([\"input\", value]);\r\n      // events.push(event);\r\n    });\r\n  },\r\n};\r\n\r\nexport default input;\r\n","'use strict';\n\n/**\n * Randomize the order of the elements in a given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Boolean} [options.copy] - Sets if should return a shuffled copy of the given array. By default it's a falsy value.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Array}\n */\nfunction shuffle(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var collection = arr,\n      len = arr.length,\n      rng = options.rng || Math.random,\n      random,\n      temp;\n\n  if (options.copy === true) {\n    collection = arr.slice();\n  }\n\n  while (len) {\n    random = Math.floor(rng() * len);\n    len -= 1;\n    temp = collection[len];\n    collection[len] = collection[random];\n    collection[random] = temp;\n  }\n\n  return collection;\n};\n\n/**\n * Pick one or more random elements from the given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Number} [options.picks] - Specifies how many random elements you want to pick. By default it picks 1.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Object}\n */\nshuffle.pick = function(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle.pick() expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var rng = options.rng || Math.random,\n      picks = options.picks || 1;\n\n  if (typeof picks === 'number' && picks !== 1) {\n    var len = arr.length,\n        collection = arr.slice(),\n        random = [],\n        index;\n\n    while (picks && len) {\n      index = Math.floor(rng() * len);\n      random.push(collection[index]);\n      collection.splice(index, 1);\n      len -= 1;\n      picks -= 1;\n    }\n\n    return random;\n  }\n\n  return arr[Math.floor(rng() * arr.length)];\n};\n\n/**\n * Expose\n */\nmodule.exports = shuffle;\n","import shuffle from \"shuffle-array\";\r\n\r\nconst queue = [];\r\n\r\nexport function getWrapX(GRID_WIDTH) {\r\n  return function wrapX(x) {\r\n    if (x >= GRID_WIDTH) return x % GRID_WIDTH;\r\n    if (x < 0) return wrapX(GRID_WIDTH + x);\r\n    return x;\r\n  };\r\n}\r\n\r\nexport function getDoesCollide(GRID_WIDTH) {\r\n  const wrapX = getWrapX(GRID_WIDTH);\r\n  return (piece, grid) => {\r\n    let shape = piece.shape;\r\n    let collides;\r\n    // rotate shape :)\r\n    shape.forEach((line, y) => {\r\n      line.forEach((block, x) => {\r\n        let _y = y + piece.y;\r\n        if (block && grid[_y] && grid[_y][wrapX(x + piece.x)]) {\r\n          collides = true;\r\n        }\r\n      });\r\n    });\r\n    return collides;\r\n  };\r\n}\r\n\r\nexport const pieces = {\r\n  i: {\r\n    shape: [\r\n      [1, 1, 1, 1],\r\n    ],\r\n  },\r\n  t: {\r\n    shape: [\r\n      [0, 1],\r\n      [1, 1, 1],\r\n    ],\r\n  },\r\n  z: {\r\n    shape: [\r\n      [1, 1],\r\n      [0, 1, 1],\r\n    ],\r\n  },\r\n  s: {\r\n    shape: [\r\n      [0, 1, 1],\r\n      [1, 1],\r\n    ],\r\n  },\r\n  o: {\r\n    shape: [\r\n      [1, 1],\r\n      [1, 1],\r\n    ],\r\n  },\r\n  l: {\r\n    shape: [\r\n      [0, 0, 1],\r\n      [1, 1, 1],\r\n    ],\r\n  },\r\n  j: {\r\n    shape: [\r\n      [1, 0, 0],\r\n      [1, 1, 1],\r\n    ],\r\n  },\r\n};\r\n\r\nexport function spawn(piece) {}\r\n\r\nexport function getNext() {\r\n  if (queue.length === 0) {\r\n    let pieceTypes = Object.keys(pieces);\r\n    shuffle(pieceTypes);\r\n    queue.push(...pieceTypes);\r\n  }\r\n  return queue[0];\r\n}\r\n","import { updateFps, renderFps } from \"./fps\";\r\nimport ModeSelector from \"./mode_selector\";\r\n// import memoize from \"lodash.memoize\";\r\nimport input from \"./input\";\r\nimport { getWrapX, getDoesCollide, pieces, spawn, getNext } from \"./game\";\r\n\r\nconst SCREEN_WIDTH = 640;\r\nconst SCREEN_HEIGHT = 480;\r\nconst GRID_WIDTH = 32;\r\nconst GRID_HEIGHT = 20;\r\nconst VOID_RADIUS = 16;\r\nconst CRUST_THICKNESS = 16;\r\nconst SCREEN_CENTRE = [(SCREEN_WIDTH - 1) / 2, (SCREEN_HEIGHT - 1) / 2];\r\nconst ACTIVE_RADIUS = SCREEN_HEIGHT / 2 - (VOID_RADIUS + CRUST_THICKNESS);\r\n\r\nlet circleRadius = SCREEN_HEIGHT - 1 * CRUST_THICKNESS;\r\nconst circle = {\r\n  x: (SCREEN_WIDTH - circleRadius) / 2,\r\n  y: CRUST_THICKNESS,\r\n  bottom: SCREEN_HEIGHT - CRUST_THICKNESS,\r\n  w: (SCREEN_WIDTH - circleRadius) / 2 + circleRadius,\r\n};\r\nlet ctx;\r\nconst events = [];\r\n\r\nconst modeSelector = new ModeSelector(selectMode, events);\r\n\r\nlet piece = {\r\n  x: 14,\r\n  y: 0,\r\n  type: \"t\",\r\n  angle: 0,\r\n};\r\n\r\nconst wrapX = getWrapX(GRID_WIDTH);\r\nconst doesCollide = getDoesCollide(GRID_WIDTH);\r\n\r\nconst grid = new Array(GRID_HEIGHT).fill(null).map((r) => {\r\n  return new Array(GRID_WIDTH).fill(0);\r\n});\r\nlet grid2;\r\n\r\ngrid[GRID_HEIGHT - 1].fill(1, 1, GRID_WIDTH - 1);\r\ngrid[GRID_HEIGHT - 2].fill(1, 2, GRID_WIDTH - 2);\r\n\r\nfunction gridLookup(x, y) {\r\n  return grid[y] && grid[y][x];\r\n}\r\n// let lookup = memoize(gridLookup, (x, y) => `${x},${y}`);\r\n\r\nfunction getGridCoords(angle, radius) {\r\n  const gridX = Math.floor((angle / (2 * Math.PI)) * GRID_WIDTH);\r\n  const gridY = Math.floor(\r\n    ((radius - VOID_RADIUS) / ACTIVE_RADIUS) * GRID_HEIGHT\r\n  );\r\n  return [gridX, gridY];\r\n}\r\n\r\nfunction renderGrid(grid) {\r\n  ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\r\n  ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);\r\n  let pixelHeight = 2;\r\n\r\n  let hue = 0;\r\n  if (modeSelector.mode === \"colour\") {\r\n    hue = (dotX / GRID_WIDTH) * 360;\r\n    ctx.fillStyle = `hsla(${hue}deg, 100%, 80%, 1.0)`;\r\n  } else if (modeSelector.mode === \"nuts\") {\r\n    hue = (dotX / (GRID_WIDTH / 20)) * 360;\r\n    ctx.fillStyle = `hsla(${hue}deg, 100%, 80%, 1.0)`;\r\n  } else if (modeSelector.mode === \"vcr\") {\r\n    ctx.fillStyle = `rgb(10,250,100)`;\r\n    pixelHeight = 1;\r\n  } else {\r\n    ctx.fillStyle = `rgb(200,200,200)`;\r\n  }\r\n\r\n  const xCentre = SCREEN_CENTRE[0];\r\n  const yCentre = SCREEN_CENTRE[1];\r\n\r\n  // for each pixel\r\n  for (let y = circle.y; y < circle.bottom; y += 2) {\r\n    for (let x = circle.x; x < circle.w; x += 2) {\r\n      const dx = x - xCentre;\r\n      const dy = y - yCentre;\r\n\r\n      const radius = Math.sqrt(dx ** 2 + dy ** 2);\r\n      const angle = getAngle(dx, dy);\r\n\r\n      const [gridX, gridY] = getGridCoords(angle, radius);\r\n\r\n      let fuzz = 0;\r\n      if (modeSelector.mode === \"fuzzy\") {\r\n        fuzz = Math.random() * 3 - 1.5;\r\n      } else if (modeSelector.mode === \"nuts\") {\r\n        fuzz = Math.random() * 6 - 3;\r\n      }\r\n      if (shock) fuzz = Math.random() * shock - shock / 2;\r\n\r\n      // if (gridLookup(gridX, gridY)) {\r\n      // if (lookup(gridX, gridY)) {\r\n      if (grid[gridY] && grid[gridY][gridX]) {\r\n        if (modeSelector.mode === \"colour\" || modeSelector.mode === \"nuts\") {\r\n          let hue2 = (hue + (angle / (2 * Math.PI)) * 360) % 360;\r\n          ctx.fillStyle = `hsla(${hue2}deg, 100%, 80%, 1.0)`;\r\n        }\r\n        ctx.fillRect(x, y, 2 + fuzz, pixelHeight + fuzz);\r\n      }\r\n    }\r\n  }\r\n  // lookup.cache.clear();\r\n}\r\n\r\nfunction getClickHandler() {\r\n  return function handleClick(e) {\r\n    const startedAt = timestamp();\r\n    var rect = e.target.getBoundingClientRect();\r\n    var x = e.clientX - rect.left; //x position within the element.\r\n    var y = e.clientY - rect.top; //y position within the element.\r\n\r\n    var scale = SCREEN_WIDTH / rect.width;\r\n\r\n    x = x * scale;\r\n    y = y * scale;\r\n\r\n    const dx = x - SCREEN_CENTRE[0];\r\n    const dy = y - SCREEN_CENTRE[1];\r\n\r\n    const radius = Math.sqrt(dx ** 2 + dy ** 2);\r\n    const angle = getAngle(dx, dy);\r\n\r\n    const [gridX, gridY] = getGridCoords(angle, radius);\r\n    grid[gridY] && (grid[gridY][gridX] = 1);\r\n  };\r\n}\r\n\r\nconst halfPi = Math.PI / 2;\r\n/**\r\n * Get angle from top, clockwise, positive\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nfunction getAngle(x, y) {\r\n  // reorient from top\r\n  let angle = Math.atan(y / x) + halfPi;\r\n  // flip around left-oriented angles\r\n  if (x < 0) angle += Math.PI;\r\n  return angle;\r\n}\r\n\r\nlet shock = 0;\r\nlet shockDecay = 0.1;\r\n\r\nfunction processEvent(event) {\r\n  console.log(event);\r\n  if (event === \"go nuts\") {\r\n    shock = 50;\r\n  } else if (event[0] === \"input\") {\r\n    switch (event[1]) {\r\n      case \"left\":\r\n        if (doesCollide({ ...piece, x: wrapX(piece.x + 1) }, grid)) {\r\n          // nope\r\n        } else {\r\n          piece.x = wrapX(piece.x + 1);\r\n        }\r\n        break;\r\n      case \"right\":\r\n        if (doesCollide({ ...piece, x: wrapX(piece.x - 1) }, grid)) {\r\n          // nope\r\n        } else {\r\n          piece.x = wrapX(piece.x - 1);\r\n        }\r\n        break;\r\n      case \"down\":\r\n        if (doesCollide({ ...piece, y: piece.y + 1 }, grid)) {\r\n          // lock piece in\r\n        } else {\r\n          piece.y += 1;\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  console.log(piece);\r\n}\r\n\r\nlet start;\r\nlet dotX = 0;\r\nconst speed = 2 / 30 / 32;\r\nlet fps;\r\n\r\nfunction update(t) {\r\n  while (events.length) {\r\n    let event = events.shift();\r\n    processEvent(event);\r\n  }\r\n  fps = updateFps(t) || fps;\r\n  dotX = wrapX(dotX + speed * t);\r\n  grid[10].fill(0);\r\n  grid[10][Math.floor(dotX)] = 1;\r\n\r\n  shock = Math.max(0, shock - shockDecay * t);\r\n\r\n  grid2 = grid.map((line) => line.slice());\r\n  piece.shape.forEach((line, y) => {\r\n    line.forEach((cell, x) => {\r\n      if (cell) {\r\n        grid2[y + piece.y][wrapX(x + piece.x)] = 2;\r\n        // console.log('block at:', wrapX(x + piece.x))\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction render() {\r\n  renderGrid(grid2);\r\n  renderFps(ctx, fps);\r\n}\r\n\r\nfunction timestamp() {\r\n  return window.performance && window.performance.now\r\n    ? window.performance.now()\r\n    : Date.now();\r\n}\r\n\r\nlet last = timestamp();\r\n\r\nfunction step() {\r\n  let now = timestamp();\r\n  if (start === undefined) start = now;\r\n  const elapsed = now - start;\r\n  let dt = Math.min(1000, now - last);\r\n  update(dt);\r\n  render();\r\n  last = now;\r\n  window.requestAnimationFrame(step);\r\n}\r\n\r\nwindow.requestAnimationFrame(step);\r\n\r\nfunction init() {\r\n  view.setAttribute(\"width\", SCREEN_WIDTH);\r\n  view.setAttribute(\"height\", SCREEN_HEIGHT);\r\n  ctx = view.getContext(\"2d\");\r\n  modeSelector.init();\r\n  input.init(document, events);\r\n  view.addEventListener(\"click\", getClickHandler());\r\n\r\n  piece.type = getNext();\r\n  piece.shape = pieces[piece.type].shape;\r\n  console.log(getNext());\r\n  window.requestAnimationFrame(step);\r\n}\r\n\r\ninit();\r\n"]}