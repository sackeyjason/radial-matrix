{"version":3,"sources":["fps.js","mode_selector.js","input.js","../node_modules/shuffle-array/index.js","game.js","geometry.js","app.js"],"names":["fpsUpdateDelay","updateFps","t","Math","round","renderFps","ctx","fps","fillStyle","fillRect","font","fillText","ModeSelector","select","events","mode","init","addEventListener","value","push","input","keyMap","el","event","keyCode","querySelectorAll","forEach","button","target","dataset","DEFAULT_OPTIONS","screenWidth","screenHeight","gridWidth","gridHeight","voidRadius","crustThickness","queue","getWrapX","GRID_WIDTH","wrapX","x","getPieceGridCoords","piece","grid","length","coords","shape","line","y","block","map","angle","xTranslation","centre","yTranslation","_x","_y","getDoesCollide","collides","pieces","i","z","s","o","l","j","spawn","type","getNext","shift","pieceTypes","Object","keys","removeLines","lines","reverse","splice","newEmptyRow","Array","fill","unshift","getCircleToGrid","GRID_HEIGHT","VOID_RADIUS","ACTIVE_RADIUS","radius","floor","PI","halfPi","getAngle","atan","grid2","SCREEN_WIDTH","SCREEN_HEIGHT","CRUST_THICKNESS","SCREEN_CENTRE","circleRadius","circle","bottom","w","modeSelector","clearing","doesCollide","r","gridLookup","getGridCoords","renderGrid","pixelHeight","hue","dotX","xCentre","yCentre","dx","dy","sqrt","gridX","gridY","fuzz","random","shock","activePiece","clearingRow","hue2","getClickHandler","e","timestamp","startedAt","rect","getBoundingClientRect","clientX","left","clientY","top","scale","width","lockPieceIn","start","shockDecay","processEvent","speed","update","max","slice","at","completeLines","undefined","find","render","window","performance","now","Date","last","step","min","requestAnimationFrame","view","setAttribute","getContext","document","console","log"],"mappings":"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","file":"app.0e128a44.js","sourceRoot":"..\\src","sourcesContent":["let fpsUpdateDelay = 0;\r\n\r\nexport function updateFps(t) {\r\n  fpsUpdateDelay += t;\r\n  if (fpsUpdateDelay > 1000) {\r\n    fpsUpdateDelay = 0;\r\n    return Math.round(1 / (t / 1000));\r\n  }\r\n}\r\n\r\n\r\nexport function renderFps(ctx, fps) {\r\n  // Draw number to the screen\r\n  ctx.fillStyle = \"#333\";\r\n  ctx.fillRect(0, 0, 80, 32);\r\n  ctx.font = \"14px Arial\";\r\n  ctx.fillStyle = \"#CCC\";\r\n  ctx.fillText(\"FPS: \" + fps, 10, 20);\r\n}\r\n","export default function ModeSelector(select, events) {\r\n  this.mode = \"normal\";\r\n  this.init = () => {\r\n    select.addEventListener(\"change\", () => {\r\n      this.mode = select.value;\r\n      if (select.value === 'nuts') {\r\n        events.push('go nuts');\r\n      }\r\n    })\r\n    select.value = 'normal';\r\n    \r\n  }\r\n}\r\n","const keyMap = {\r\n  37: \"left\",\r\n  38: \"rotateR\",\r\n  39: \"right\",\r\n  40: \"down\",\r\n  90: \"rotateL\",\r\n  88: \"rotateR\",\r\n  32: \"hardDrop\",\r\n};\r\n\r\nconst input = {\r\n  init: (el, events) => {\r\n    el.addEventListener(\"keydown\", (event) => {\r\n      // console.log('event: ', event);\r\n      const value = keyMap[event.keyCode];\r\n      if (value) events.push([\"input\", value]);\r\n    });\r\n    el.querySelectorAll(\"button\").forEach((button) => {\r\n      button.addEventListener(\"touchstart\", (event) => {\r\n        events.push([\"input\", event.target.dataset.input]);\r\n      });\r\n    });\r\n  },\r\n};\r\n\r\nexport default input;\r\n","'use strict';\n\n/**\n * Randomize the order of the elements in a given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Boolean} [options.copy] - Sets if should return a shuffled copy of the given array. By default it's a falsy value.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Array}\n */\nfunction shuffle(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var collection = arr,\n      len = arr.length,\n      rng = options.rng || Math.random,\n      random,\n      temp;\n\n  if (options.copy === true) {\n    collection = arr.slice();\n  }\n\n  while (len) {\n    random = Math.floor(rng() * len);\n    len -= 1;\n    temp = collection[len];\n    collection[len] = collection[random];\n    collection[random] = temp;\n  }\n\n  return collection;\n};\n\n/**\n * Pick one or more random elements from the given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Number} [options.picks] - Specifies how many random elements you want to pick. By default it picks 1.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Object}\n */\nshuffle.pick = function(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle.pick() expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var rng = options.rng || Math.random,\n      picks = options.picks || 1;\n\n  if (typeof picks === 'number' && picks !== 1) {\n    var len = arr.length,\n        collection = arr.slice(),\n        random = [],\n        index;\n\n    while (picks && len) {\n      index = Math.floor(rng() * len);\n      random.push(collection[index]);\n      collection.splice(index, 1);\n      len -= 1;\n      picks -= 1;\n    }\n\n    return random;\n  }\n\n  return arr[Math.floor(rng() * arr.length)];\n};\n\n/**\n * Expose\n */\nmodule.exports = shuffle;\n","const DEFAULT_OPTIONS = {\r\n  screenWidth: 640,\r\n  screenHeight: 480,\r\n  gridWidth: 32,\r\n  gridHeight: 20,\r\n  voidRadius: 16,\r\n  crustThickness: 16,\r\n};\r\n\r\nimport shuffle from \"shuffle-array\";\r\n\r\nconst queue = [];\r\n\r\nexport function getWrapX(GRID_WIDTH) {\r\n  return function wrapX(x) {\r\n    if (x >= GRID_WIDTH) return x % GRID_WIDTH;\r\n    if (x < 0) return wrapX(GRID_WIDTH + x);\r\n    return x;\r\n  };\r\n}\r\n\r\nexport function getPieceGridCoords(piece, grid) {\r\n  // console.log('grid: ', grid[0]);\r\n  const wrapX = getWrapX(grid[0].length);\r\n  let coords = [];\r\n\r\n  piece.shape.forEach((line, y) => {\r\n    line.forEach((block, x) => {\r\n      if (block) {\r\n        coords.push([x + piece.x, y + piece.y]);\r\n      }\r\n    });\r\n  });\r\n\r\n  coords = coords.map(([x, y]) => {\r\n    if (piece.angle === 0) return [wrapX(x), y];\r\n    let xTranslation = piece.x + piece.centre[0];\r\n    let yTranslation = piece.y + piece.centre[1];\r\n    let _x = x - xTranslation;\r\n    let _y = y - yTranslation;\r\n\r\n    if (piece.angle === 1) {\r\n      [_x, _y] = [_y, -_x];\r\n    } else if (piece.angle === 2) {\r\n      [_x, _y] = [-_x, -_y];\r\n    } else if (piece.angle === 3) {\r\n      [_x, _y] = [-_y, _x];\r\n    }\r\n\r\n    _x += xTranslation;\r\n    _y += yTranslation;\r\n    return [wrapX(_x), _y];\r\n  });\r\n\r\n  return coords;\r\n}\r\n\r\n// use getPieceGridCoords\r\nexport function getDoesCollide() {\r\n  return (piece, grid) => {\r\n    const coords = getPieceGridCoords(piece, grid);\r\n    let collides;\r\n    coords.forEach(([x, y]) => {\r\n      if (y >= grid.length) collides = true;\r\n      if (grid[y] && grid[y][x]) {\r\n        collides = true;\r\n      }\r\n    });\r\n    return collides;\r\n  };\r\n}\r\n\r\nexport const pieces = {\r\n  i: {\r\n    shape: [[1, 1, 1, 1]],\r\n    centre: [1.5, 0.5],\r\n  },\r\n  t: {\r\n    shape: [\r\n      [0, 1],\r\n      [1, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  z: {\r\n    shape: [\r\n      [1, 1],\r\n      [0, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  s: {\r\n    shape: [\r\n      [0, 1, 1],\r\n      [1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  o: {\r\n    shape: [\r\n      [1, 1],\r\n      [1, 1],\r\n    ],\r\n    centre: [0.5, 0.5],\r\n  },\r\n  l: {\r\n    shape: [\r\n      [0, 0, 1],\r\n      [1, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  j: {\r\n    shape: [\r\n      [1, 0, 0],\r\n      [1, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n};\r\n\r\nexport function spawn() {\r\n  const piece = {\r\n    x: 14,\r\n    y: 0,\r\n    type: getNext(),\r\n    angle: 0,\r\n  };\r\n  piece.shape = pieces[piece.type].shape;\r\n  piece.centre = pieces[piece.type].centre;\r\n  queue.shift();\r\n  return piece;\r\n}\r\n\r\nexport function getNext() {\r\n  if (queue.length === 0) {\r\n    let pieceTypes = Object.keys(pieces);\r\n    shuffle(pieceTypes);\r\n    queue.push(...pieceTypes);\r\n  }\r\n  return queue[0];\r\n}\r\n\r\nexport function removeLines(lines, grid) {\r\n  lines.reverse().forEach((y) => {\r\n    grid.splice(y, 1);\r\n  });\r\n  for (let i = 0; i < lines.length; i++) {\r\n    let newEmptyRow = new Array(32).fill(0);\r\n    grid.unshift(newEmptyRow);\r\n  }\r\n}\r\n","export const getCircleToGrid = ({\r\n  GRID_WIDTH,\r\n  GRID_HEIGHT,\r\n  VOID_RADIUS,\r\n  ACTIVE_RADIUS,\r\n}) =>\r\n  function getGridCoords(angle, radius) {\r\n    const gridX = Math.floor((angle / (2 * Math.PI)) * GRID_WIDTH);\r\n    const gridY = Math.floor(\r\n      ((radius - VOID_RADIUS) / ACTIVE_RADIUS) * GRID_HEIGHT\r\n    );\r\n    return [gridX, gridY];\r\n  };\r\n\r\nconst halfPi = Math.PI / 2;\r\n/**\r\n * Get angle from top, clockwise, positive\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nexport function getAngle(x, y) {\r\n  // reorient from top\r\n  let angle = Math.atan(y / x) + halfPi;\r\n  // flip around left-oriented angles\r\n  if (x < 0) angle += Math.PI;\r\n  return angle;\r\n}\r\n","import { updateFps, renderFps } from \"./fps\";\r\nimport ModeSelector from \"./mode_selector\";\r\n// import memoize from \"lodash.memoize\";\r\nimport input from \"./input\";\r\nimport {\r\n  getWrapX,\r\n  getPieceGridCoords,\r\n  getDoesCollide,\r\n  pieces,\r\n  spawn,\r\n  getNext,\r\n  removeLines,\r\n} from \"./game\";\r\nimport { getCircleToGrid, getAngle } from \"./geometry\";\r\n\r\nconst SCREEN_WIDTH = 640;\r\nconst SCREEN_HEIGHT = 480;\r\nconst GRID_WIDTH = 32;\r\nconst GRID_HEIGHT = 14;\r\nconst VOID_RADIUS = 16;\r\nconst CRUST_THICKNESS = 16;\r\nconst SCREEN_CENTRE = [(SCREEN_WIDTH - 1) / 2, (SCREEN_HEIGHT - 1) / 2];\r\nconst ACTIVE_RADIUS = SCREEN_HEIGHT / 2 - (VOID_RADIUS + CRUST_THICKNESS);\r\n\r\nlet circleRadius = SCREEN_HEIGHT - 1 * CRUST_THICKNESS;\r\nconst circle = {\r\n  x: (SCREEN_WIDTH - circleRadius) / 2,\r\n  y: CRUST_THICKNESS,\r\n  bottom: SCREEN_HEIGHT - CRUST_THICKNESS,\r\n  w: (SCREEN_WIDTH - circleRadius) / 2 + circleRadius,\r\n};\r\nlet ctx;\r\nconst events = [];\r\n\r\nconst modeSelector = {};\r\n\r\nlet clearing = null;\r\n\r\nlet piece = {\r\n  x: 14,\r\n  y: 0,\r\n  type: \"t\",\r\n  angle: 0,\r\n};\r\n\r\nconst wrapX = getWrapX(GRID_WIDTH);\r\nconst doesCollide = getDoesCollide(GRID_WIDTH);\r\n\r\nconst grid = new Array(GRID_HEIGHT).fill(null).map((r) => {\r\n  return new Array(GRID_WIDTH).fill(0);\r\n});\r\nlet grid2;\r\n\r\ngrid[GRID_HEIGHT - 1].fill(1, 1, GRID_WIDTH - 1);\r\ngrid[GRID_HEIGHT - 2].fill(1, 2, GRID_WIDTH - 2);\r\n\r\nfunction gridLookup(x, y) {\r\n  return grid[y] && grid[y][x];\r\n}\r\n// let lookup = memoize(gridLookup, (x, y) => `${x},${y}`);\r\n\r\nconst getGridCoords = getCircleToGrid({\r\n  GRID_WIDTH,\r\n  GRID_HEIGHT,\r\n  VOID_RADIUS,\r\n  ACTIVE_RADIUS,\r\n});\r\n\r\n// function getGridCoords(angle, radius) {\r\n//   const gridX = Math.floor((angle / (2 * Math.PI)) * GRID_WIDTH);\r\n//   const gridY = Math.floor(\r\n//     ((radius - VOID_RADIUS) / ACTIVE_RADIUS) * GRID_HEIGHT\r\n//   );\r\n//   return [gridX, gridY];\r\n// }\r\n\r\nfunction renderGrid(grid) {\r\n  ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\r\n  ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);\r\n  let pixelHeight = 2;\r\n\r\n  let hue = 0;\r\n  if (modeSelector.mode === \"colour\") {\r\n    hue = (dotX / GRID_WIDTH) * 360;\r\n    ctx.fillStyle = `hsla(${hue}deg, 100%, 80%, 1.0)`;\r\n  } else if (modeSelector.mode === \"nuts\") {\r\n    hue = (dotX / (GRID_WIDTH / 20)) * 360;\r\n    ctx.fillStyle = `hsla(${hue}deg, 100%, 80%, 1.0)`;\r\n  } else if (modeSelector.mode === \"vcr\") {\r\n    ctx.fillStyle = `rgb(10,250,100)`;\r\n    pixelHeight = 1;\r\n  } else {\r\n    ctx.fillStyle = `rgb(200,200,200)`;\r\n  }\r\n\r\n  const xCentre = SCREEN_CENTRE[0];\r\n  const yCentre = SCREEN_CENTRE[1];\r\n\r\n  // for each pixel\r\n  for (let y = circle.y; y < circle.bottom; y += 2) {\r\n    for (let x = circle.x; x < circle.w; x += 2) {\r\n      const dx = x - xCentre;\r\n      const dy = y - yCentre;\r\n\r\n      const radius = Math.sqrt(dx ** 2 + dy ** 2);\r\n      const angle = getAngle(dx, dy);\r\n\r\n      const [gridX, gridY] = getGridCoords(angle, radius);\r\n\r\n      let fuzz = 0;\r\n      if (modeSelector.mode === \"fuzzy\") {\r\n        fuzz = Math.random() * 3 - 1.5;\r\n      } else if (modeSelector.mode === \"nuts\") {\r\n        fuzz = Math.random() * 6 - 3;\r\n      }\r\n      if (shock) fuzz = Math.random() * shock - shock / 2;\r\n\r\n      // if (gridLookup(gridX, gridY)) {\r\n      // if (lookup(gridX, gridY)) {\r\n      if (grid[gridY] && grid[gridY][gridX]) {\r\n        const activePiece = grid[gridY][gridX] === 2;\r\n        const clearingRow = grid[gridY][gridX] === 3;\r\n        if (modeSelector.mode === \"colour\" || modeSelector.mode === \"nuts\") {\r\n          let hue2 = (hue + (angle / (2 * Math.PI)) * 360) % 360;\r\n          ctx.fillStyle = `hsla(${hue2}deg, 100%, 80%, 1.0)`;\r\n        } else {\r\n          if (activePiece) {\r\n            ctx.fillStyle = `rgb(255,100,50)`;\r\n          } else if (clearingRow) {\r\n            fuzz = Math.random() * 3 - 1.5;\r\n            let hue2 = (hue + (angle / (2 * Math.PI)) * 360) % 360;\r\n            ctx.fillStyle = `hsla(${hue2}deg, 100%, 80%, 1.0)`;\r\n          } else {\r\n            ctx.fillStyle = `rgb(200,200,200)`;\r\n          }\r\n        }\r\n        ctx.fillRect(x, y, 2 + fuzz, pixelHeight + fuzz);\r\n      }\r\n    }\r\n  }\r\n  // lookup.cache.clear();\r\n}\r\n\r\nfunction getClickHandler() {\r\n  return function handleClick(e) {\r\n    const startedAt = timestamp();\r\n    var rect = e.target.getBoundingClientRect();\r\n    var x = e.clientX - rect.left; //x position within the element.\r\n    var y = e.clientY - rect.top; //y position within the element.\r\n\r\n    var scale = SCREEN_WIDTH / rect.width;\r\n\r\n    x = x * scale;\r\n    y = y * scale;\r\n\r\n    const dx = x - SCREEN_CENTRE[0];\r\n    const dy = y - SCREEN_CENTRE[1];\r\n\r\n    const radius = Math.sqrt(dx ** 2 + dy ** 2);\r\n    const angle = getAngle(dx, dy);\r\n\r\n    const [gridX, gridY] = getGridCoords(angle, radius);\r\n    grid[gridY] && (grid[gridY][gridX] = 1);\r\n  };\r\n}\r\n\r\nfunction lockPieceIn() {\r\n  getPieceGridCoords(piece, grid).forEach(([x, y]) => {\r\n    if (grid[y]) grid[y][x] = 1;\r\n  });\r\n  piece = null;\r\n}\r\n\r\nlet shock = 0;\r\nlet shockDecay = 0.1;\r\n\r\nfunction processEvent(event) {\r\n  // console.log(event);\r\n  if (event === \"go nuts\") {\r\n    shock = 50;\r\n  } else if (event[0] === \"input\") {\r\n    if (piece) {\r\n      switch (event[1]) {\r\n        case \"left\":\r\n          if (doesCollide({ ...piece, x: wrapX(piece.x + 1) }, grid)) {\r\n            // clunk\r\n          } else {\r\n            piece.x = wrapX(piece.x + 1);\r\n          }\r\n          break;\r\n        case \"right\":\r\n          if (doesCollide({ ...piece, x: wrapX(piece.x - 1) }, grid)) {\r\n            // clonk\r\n          } else {\r\n            piece.x = wrapX(piece.x - 1);\r\n          }\r\n          break;\r\n        case \"down\":\r\n          if (doesCollide({ ...piece, y: piece.y + 1 }, grid)) {\r\n            lockPieceIn();\r\n          } else {\r\n            piece.y += 1;\r\n          }\r\n          break;\r\n        case 'rotateR':\r\n          piece.angle = (piece.angle + 1) % 4;\r\n          break;\r\n        case 'rotateL':\r\n          piece.angle = (piece.angle - 1);\r\n          if (piece.angle < 0) piece.angle = 3;\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  } else if (event[0] === \"clear\") {\r\n  }\r\n  // console.log(piece);\r\n  // console.log(piece && getPieceGridCoords(piece, grid));\r\n}\r\n\r\nlet start;\r\nlet dotX = 0;\r\nconst speed = 2 / 30 / 32;\r\nlet fps;\r\n\r\nfunction update(t) {\r\n  while (events.length) {\r\n    let event = events.shift();\r\n    processEvent(event);\r\n  }\r\n  fps = updateFps(t) || fps;\r\n  dotX = wrapX(dotX + speed * t);\r\n\r\n  shock = Math.max(0, shock - shockDecay * t);\r\n\r\n  grid2 = grid.map((line) => line.slice());\r\n  if (piece) {\r\n    const pieceCoords = getPieceGridCoords(piece, grid);\r\n    pieceCoords.forEach(([x, y]) => {\r\n      if (y < 0) return;\r\n      if (grid2[y]) grid2[y][x] = 2;\r\n    });\r\n  } else if (clearing) {\r\n    // animating\r\n    if (timestamp() - clearing.at >= 500) {\r\n      removeLines(clearing.lines, grid);\r\n      grid2 = grid;\r\n      clearing = null;\r\n    }\r\n  } else {\r\n    const completeLines = [];\r\n    grid2.forEach((line, y) => {\r\n      if (line.find((block) => block === 0) === undefined) {\r\n        completeLines.push(y);\r\n        grid[y].fill(3);\r\n      }\r\n    });\r\n    if (completeLines.length) {\r\n      clearing = {\r\n        lines: completeLines,\r\n        at: timestamp(),\r\n      };\r\n    } else {\r\n      piece = spawn();\r\n    }\r\n  }\r\n}\r\n\r\nfunction render() {\r\n  renderGrid(grid2);\r\n  renderFps(ctx, fps);\r\n}\r\n\r\nfunction timestamp() {\r\n  return window.performance && window.performance.now\r\n    ? window.performance.now()\r\n    : Date.now();\r\n}\r\n\r\nlet last = timestamp();\r\n\r\nfunction step() {\r\n  let now = timestamp();\r\n  if (start === undefined) start = now;\r\n  const elapsed = now - start;\r\n  let dt = Math.min(1000, now - last);\r\n  update(dt);\r\n  render();\r\n  last = now;\r\n  window.requestAnimationFrame(step);\r\n}\r\n\r\nwindow.requestAnimationFrame(step);\r\n\r\nfunction init() {\r\n  view.setAttribute(\"width\", SCREEN_WIDTH);\r\n  view.setAttribute(\"height\", SCREEN_HEIGHT);\r\n  ctx = view.getContext(\"2d\");\r\n  // modeSelector.init();\r\n  input.init(document, events);\r\n  view.addEventListener(\"click\", getClickHandler());\r\n\r\n  piece = spawn();\r\n  console.log(getNext());\r\n  window.requestAnimationFrame(step);\r\n}\r\n\r\ninit();\r\n"]}