{"version":3,"sources":["fps.js","mode_selector.js","input.js","../node_modules/shuffle-array/index.js","game.js","geometry.js","app.js"],"names":["fpsUpdateDelay","updateFps","t","Math","round","renderFps","ctx","fps","fillStyle","fillRect","font","fillText","ModeSelector","select","events","mode","init","addEventListener","value","push","input","keyMap","el","event","keyCode","DEFAULT_OPTIONS","screenWidth","screenHeight","gridWidth","gridHeight","voidRadius","crustThickness","queue","getWrapX","GRID_WIDTH","wrapX","x","getPieceGridCoords","piece","grid","length","coords","shape","forEach","line","y","block","map","angle","xTranslation","centre","yTranslation","_x","_y","getDoesCollide","collides","console","log","pieces","i","z","s","o","l","j","spawn","type","getNext","shift","pieceTypes","Object","keys","removeLines","lines","reverse","splice","newEmptyRow","Array","fill","unshift","getCircleToGrid","GRID_HEIGHT","VOID_RADIUS","ACTIVE_RADIUS","radius","floor","PI","halfPi","getAngle","atan","grid2","SCREEN_WIDTH","SCREEN_HEIGHT","CRUST_THICKNESS","SCREEN_CENTRE","circleRadius","circle","bottom","w","modeSelector","selectMode","clearing","doesCollide","r","gridLookup","getGridCoords","renderGrid","pixelHeight","hue","dotX","xCentre","yCentre","dx","dy","sqrt","gridX","gridY","fuzz","random","shock","activePiece","clearingRow","hue2","getClickHandler","e","timestamp","startedAt","rect","target","getBoundingClientRect","clientX","left","clientY","top","scale","width","lockPieceIn","start","shockDecay","processEvent","speed","update","max","slice","at","completeLines","undefined","find","render","window","performance","now","Date","last","step","min","requestAnimationFrame","view","setAttribute","getContext","document"],"mappings":"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","file":"app.75060d14.js","sourceRoot":"..\\src","sourcesContent":["let fpsUpdateDelay = 0;\r\n\r\nexport function updateFps(t) {\r\n  fpsUpdateDelay += t;\r\n  if (fpsUpdateDelay > 1000) {\r\n    fpsUpdateDelay = 0;\r\n    return Math.round(1 / (t / 1000));\r\n  }\r\n}\r\n\r\n\r\nexport function renderFps(ctx, fps) {\r\n  // Draw number to the screen\r\n  ctx.fillStyle = \"#333\";\r\n  ctx.fillRect(0, 0, 80, 32);\r\n  ctx.font = \"14px Arial\";\r\n  ctx.fillStyle = \"#CCC\";\r\n  ctx.fillText(\"FPS: \" + fps, 10, 20);\r\n}\r\n","export default function ModeSelector(select, events) {\r\n  this.mode = \"normal\";\r\n  this.init = () => {\r\n    select.addEventListener(\"change\", () => {\r\n      this.mode = select.value;\r\n      if (select.value === 'nuts') {\r\n        events.push('go nuts');\r\n      }\r\n    })\r\n    select.value = 'normal';\r\n    \r\n  }\r\n}\r\n","const keyMap = {\r\n  37: 'left',\r\n  38: 'up',\r\n  39: 'right',\r\n  40: 'down',\r\n  90: 'b',\r\n  88: 'a'\r\n};\r\n\r\nconst input = {\r\n  init: (el, events) => {\r\n    el.addEventListener(\"keydown\", (event) => {\r\n      const value = keyMap[event.keyCode];\r\n      if (value) events.push([\"input\", value]);\r\n    });\r\n  },\r\n};\r\n\r\nexport default input;\r\n","'use strict';\n\n/**\n * Randomize the order of the elements in a given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Boolean} [options.copy] - Sets if should return a shuffled copy of the given array. By default it's a falsy value.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Array}\n */\nfunction shuffle(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var collection = arr,\n      len = arr.length,\n      rng = options.rng || Math.random,\n      random,\n      temp;\n\n  if (options.copy === true) {\n    collection = arr.slice();\n  }\n\n  while (len) {\n    random = Math.floor(rng() * len);\n    len -= 1;\n    temp = collection[len];\n    collection[len] = collection[random];\n    collection[random] = temp;\n  }\n\n  return collection;\n};\n\n/**\n * Pick one or more random elements from the given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Number} [options.picks] - Specifies how many random elements you want to pick. By default it picks 1.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Object}\n */\nshuffle.pick = function(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle.pick() expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var rng = options.rng || Math.random,\n      picks = options.picks || 1;\n\n  if (typeof picks === 'number' && picks !== 1) {\n    var len = arr.length,\n        collection = arr.slice(),\n        random = [],\n        index;\n\n    while (picks && len) {\n      index = Math.floor(rng() * len);\n      random.push(collection[index]);\n      collection.splice(index, 1);\n      len -= 1;\n      picks -= 1;\n    }\n\n    return random;\n  }\n\n  return arr[Math.floor(rng() * arr.length)];\n};\n\n/**\n * Expose\n */\nmodule.exports = shuffle;\n","const DEFAULT_OPTIONS = {\r\n  screenWidth: 640,\r\n  screenHeight: 480,\r\n  gridWidth: 32,\r\n  gridHeight: 20,\r\n  voidRadius: 16,\r\n  crustThickness: 16,\r\n};\r\n\r\nimport shuffle from \"shuffle-array\";\r\n\r\nconst queue = [];\r\n\r\nexport function getWrapX(GRID_WIDTH) {\r\n  return function wrapX(x) {\r\n    if (x >= GRID_WIDTH) return x % GRID_WIDTH;\r\n    if (x < 0) return wrapX(GRID_WIDTH + x);\r\n    return x;\r\n  };\r\n}\r\n\r\nexport function getPieceGridCoords(piece, grid) {\r\n  const wrapX = getWrapX(grid[0].length);\r\n  let coords = [];\r\n\r\n  piece.shape.forEach((line, y) => {\r\n    line.forEach((block, x) => {\r\n      if (block) {\r\n        coords.push([wrapX(x + piece.x), y + piece.y]);\r\n      }\r\n    });\r\n  });\r\n\r\n  coords = coords.map(([x, y]) => {\r\n    if (piece.angle === 0) return [x, y];\r\n    let xTranslation = piece.x + piece.centre[0];\r\n    let yTranslation = piece.y + piece.centre[1];\r\n    let _x = x - xTranslation;\r\n    let _y = y - yTranslation;\r\n\r\n    if (piece.angle === 1) {\r\n      [_x, _y] = [_y, -_x];\r\n    } else if (piece.angle === 2) {\r\n      [_x, _y] = [-_x, -_y];\r\n    } else if (piece.angle === 3) {\r\n      [_x, _y] = [-_y, _x];\r\n    }\r\n\r\n    _x += xTranslation;\r\n    _y += yTranslation;\r\n    return [wrapX(_x), _y];\r\n  });\r\n\r\n  return coords;\r\n}\r\n\r\n// use getPieceGridCoords\r\nexport function getDoesCollide(GRID_WIDTH) {\r\n  return (piece, grid) => {\r\n    const coords = getPieceGridCoords(piece, grid);\r\n    console.log(\"coords: \", coords);\r\n    let collides;\r\n    coords.forEach(([x, y]) => {\r\n      if (y >= grid.length) collides = true;\r\n      if (grid[y] && grid[y][x]) {\r\n        collides = true;\r\n      }\r\n    });\r\n    return collides;\r\n  };\r\n}\r\n\r\nexport const pieces = {\r\n  i: {\r\n    shape: [[1, 1, 1, 1]],\r\n    centre: [1.5, 0.5],\r\n  },\r\n  t: {\r\n    shape: [\r\n      [0, 1],\r\n      [1, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  z: {\r\n    shape: [\r\n      [1, 1],\r\n      [0, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  s: {\r\n    shape: [\r\n      [0, 1, 1],\r\n      [1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  o: {\r\n    shape: [\r\n      [1, 1],\r\n      [1, 1],\r\n    ],\r\n    centre: [0.5, 0.5],\r\n  },\r\n  l: {\r\n    shape: [\r\n      [0, 0, 1],\r\n      [1, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n  j: {\r\n    shape: [\r\n      [1, 0, 0],\r\n      [1, 1, 1],\r\n    ],\r\n    centre: [1, 1],\r\n  },\r\n};\r\n\r\nexport function spawn() {\r\n  const piece = {\r\n    x: 14,\r\n    y: 0,\r\n    type: getNext(),\r\n    angle: 0,\r\n  };\r\n  piece.shape = pieces[piece.type].shape;\r\n  piece.centre = pieces[piece.type].centre;\r\n  queue.shift();\r\n  return piece;\r\n}\r\n\r\nexport function getNext() {\r\n  if (queue.length === 0) {\r\n    let pieceTypes = Object.keys(pieces);\r\n    shuffle(pieceTypes);\r\n    queue.push(...pieceTypes);\r\n  }\r\n  return queue[0];\r\n}\r\n\r\nexport function removeLines(lines, grid) {\r\n  lines.reverse().forEach((y) => {\r\n    grid.splice(y, 1);\r\n  });\r\n  for (let i = 0; i < lines.length; i++) {\r\n    let newEmptyRow = new Array(32).fill(0);\r\n    grid.unshift(newEmptyRow);\r\n  }\r\n}\r\n","export const getCircleToGrid = ({\r\n  GRID_WIDTH,\r\n  GRID_HEIGHT,\r\n  VOID_RADIUS,\r\n  ACTIVE_RADIUS,\r\n}) =>\r\n  function getGridCoords(angle, radius) {\r\n    const gridX = Math.floor((angle / (2 * Math.PI)) * GRID_WIDTH);\r\n    const gridY = Math.floor(\r\n      ((radius - VOID_RADIUS) / ACTIVE_RADIUS) * GRID_HEIGHT\r\n    );\r\n    return [gridX, gridY];\r\n  };\r\n\r\nconst halfPi = Math.PI / 2;\r\n/**\r\n * Get angle from top, clockwise, positive\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nexport function getAngle(x, y) {\r\n  // reorient from top\r\n  let angle = Math.atan(y / x) + halfPi;\r\n  // flip around left-oriented angles\r\n  if (x < 0) angle += Math.PI;\r\n  return angle;\r\n}\r\n","import { updateFps, renderFps } from \"./fps\";\r\nimport ModeSelector from \"./mode_selector\";\r\n// import memoize from \"lodash.memoize\";\r\nimport input from \"./input\";\r\nimport {\r\n  getWrapX,\r\n  getPieceGridCoords,\r\n  getDoesCollide,\r\n  pieces,\r\n  spawn,\r\n  getNext,\r\n  removeLines,\r\n} from \"./game\";\r\nimport { getCircleToGrid, getAngle } from \"./geometry\";\r\n\r\nconst SCREEN_WIDTH = 640;\r\nconst SCREEN_HEIGHT = 480;\r\nconst GRID_WIDTH = 32;\r\nconst GRID_HEIGHT = 20;\r\nconst VOID_RADIUS = 16;\r\nconst CRUST_THICKNESS = 16;\r\nconst SCREEN_CENTRE = [(SCREEN_WIDTH - 1) / 2, (SCREEN_HEIGHT - 1) / 2];\r\nconst ACTIVE_RADIUS = SCREEN_HEIGHT / 2 - (VOID_RADIUS + CRUST_THICKNESS);\r\n\r\nlet circleRadius = SCREEN_HEIGHT - 1 * CRUST_THICKNESS;\r\nconst circle = {\r\n  x: (SCREEN_WIDTH - circleRadius) / 2,\r\n  y: CRUST_THICKNESS,\r\n  bottom: SCREEN_HEIGHT - CRUST_THICKNESS,\r\n  w: (SCREEN_WIDTH - circleRadius) / 2 + circleRadius,\r\n};\r\nlet ctx;\r\nconst events = [];\r\n\r\nconst modeSelector = new ModeSelector(selectMode, events);\r\n\r\nlet clearing = null;\r\n\r\nlet piece = {\r\n  x: 14,\r\n  y: 0,\r\n  type: \"t\",\r\n  angle: 0,\r\n};\r\n\r\nconst wrapX = getWrapX(GRID_WIDTH);\r\nconst doesCollide = getDoesCollide(GRID_WIDTH);\r\n\r\nconst grid = new Array(GRID_HEIGHT).fill(null).map((r) => {\r\n  return new Array(GRID_WIDTH).fill(0);\r\n});\r\nlet grid2;\r\n\r\ngrid[GRID_HEIGHT - 1].fill(1, 1, GRID_WIDTH - 1);\r\ngrid[GRID_HEIGHT - 2].fill(1, 2, GRID_WIDTH - 2);\r\n\r\nfunction gridLookup(x, y) {\r\n  return grid[y] && grid[y][x];\r\n}\r\n// let lookup = memoize(gridLookup, (x, y) => `${x},${y}`);\r\n\r\nconst getGridCoords = getCircleToGrid({\r\n  GRID_WIDTH,\r\n  GRID_HEIGHT,\r\n  VOID_RADIUS,\r\n  ACTIVE_RADIUS,\r\n});\r\n\r\n// function getGridCoords(angle, radius) {\r\n//   const gridX = Math.floor((angle / (2 * Math.PI)) * GRID_WIDTH);\r\n//   const gridY = Math.floor(\r\n//     ((radius - VOID_RADIUS) / ACTIVE_RADIUS) * GRID_HEIGHT\r\n//   );\r\n//   return [gridX, gridY];\r\n// }\r\n\r\nfunction renderGrid(grid) {\r\n  ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\r\n  ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);\r\n  let pixelHeight = 2;\r\n\r\n  let hue = 0;\r\n  if (modeSelector.mode === \"colour\") {\r\n    hue = (dotX / GRID_WIDTH) * 360;\r\n    ctx.fillStyle = `hsla(${hue}deg, 100%, 80%, 1.0)`;\r\n  } else if (modeSelector.mode === \"nuts\") {\r\n    hue = (dotX / (GRID_WIDTH / 20)) * 360;\r\n    ctx.fillStyle = `hsla(${hue}deg, 100%, 80%, 1.0)`;\r\n  } else if (modeSelector.mode === \"vcr\") {\r\n    ctx.fillStyle = `rgb(10,250,100)`;\r\n    pixelHeight = 1;\r\n  } else {\r\n    ctx.fillStyle = `rgb(200,200,200)`;\r\n  }\r\n\r\n  const xCentre = SCREEN_CENTRE[0];\r\n  const yCentre = SCREEN_CENTRE[1];\r\n\r\n  // for each pixel\r\n  for (let y = circle.y; y < circle.bottom; y += 2) {\r\n    for (let x = circle.x; x < circle.w; x += 2) {\r\n      const dx = x - xCentre;\r\n      const dy = y - yCentre;\r\n\r\n      const radius = Math.sqrt(dx ** 2 + dy ** 2);\r\n      const angle = getAngle(dx, dy);\r\n\r\n      const [gridX, gridY] = getGridCoords(angle, radius);\r\n\r\n      let fuzz = 0;\r\n      if (modeSelector.mode === \"fuzzy\") {\r\n        fuzz = Math.random() * 3 - 1.5;\r\n      } else if (modeSelector.mode === \"nuts\") {\r\n        fuzz = Math.random() * 6 - 3;\r\n      }\r\n      if (shock) fuzz = Math.random() * shock - shock / 2;\r\n\r\n      // if (gridLookup(gridX, gridY)) {\r\n      // if (lookup(gridX, gridY)) {\r\n      if (grid[gridY] && grid[gridY][gridX]) {\r\n        const activePiece = grid[gridY][gridX] === 2;\r\n        const clearingRow = grid[gridY][gridX] === 3;\r\n        if (modeSelector.mode === \"colour\" || modeSelector.mode === \"nuts\") {\r\n          let hue2 = (hue + (angle / (2 * Math.PI)) * 360) % 360;\r\n          ctx.fillStyle = `hsla(${hue2}deg, 100%, 80%, 1.0)`;\r\n        } else {\r\n          if (activePiece) {\r\n            ctx.fillStyle = `rgb(255,100,50)`;\r\n          } else if (clearingRow) {\r\n            fuzz = Math.random() * 3 - 1.5;\r\n            let hue2 = (hue + (angle / (2 * Math.PI)) * 360) % 360;\r\n            ctx.fillStyle = `hsla(${hue2}deg, 100%, 80%, 1.0)`;\r\n          } else {\r\n            ctx.fillStyle = `rgb(200,200,200)`;\r\n          }\r\n        }\r\n        ctx.fillRect(x, y, 2 + fuzz, pixelHeight + fuzz);\r\n      }\r\n    }\r\n  }\r\n  // lookup.cache.clear();\r\n}\r\n\r\nfunction getClickHandler() {\r\n  return function handleClick(e) {\r\n    const startedAt = timestamp();\r\n    var rect = e.target.getBoundingClientRect();\r\n    var x = e.clientX - rect.left; //x position within the element.\r\n    var y = e.clientY - rect.top; //y position within the element.\r\n\r\n    var scale = SCREEN_WIDTH / rect.width;\r\n\r\n    x = x * scale;\r\n    y = y * scale;\r\n\r\n    const dx = x - SCREEN_CENTRE[0];\r\n    const dy = y - SCREEN_CENTRE[1];\r\n\r\n    const radius = Math.sqrt(dx ** 2 + dy ** 2);\r\n    const angle = getAngle(dx, dy);\r\n\r\n    const [gridX, gridY] = getGridCoords(angle, radius);\r\n    grid[gridY] && (grid[gridY][gridX] = 1);\r\n  };\r\n}\r\n\r\nfunction lockPieceIn() {\r\n  getPieceGridCoords(piece, grid).forEach(([x, y]) => {\r\n    if (grid[y]) grid[y][x] = 1;\r\n  });\r\n  piece = null;\r\n}\r\n\r\nlet shock = 0;\r\nlet shockDecay = 0.1;\r\n\r\nfunction processEvent(event) {\r\n  console.log(event);\r\n  if (event === \"go nuts\") {\r\n    shock = 50;\r\n  } else if (event[0] === \"input\") {\r\n    if (piece) {\r\n      switch (event[1]) {\r\n        case \"left\":\r\n          if (doesCollide({ ...piece, x: wrapX(piece.x + 1) }, grid)) {\r\n            // clunk\r\n          } else {\r\n            piece.x = wrapX(piece.x + 1);\r\n          }\r\n          break;\r\n        case \"right\":\r\n          if (doesCollide({ ...piece, x: wrapX(piece.x - 1) }, grid)) {\r\n            // clonk\r\n          } else {\r\n            piece.x = wrapX(piece.x - 1);\r\n          }\r\n          break;\r\n        case \"down\":\r\n          if (doesCollide({ ...piece, y: piece.y + 1 }, grid)) {\r\n            lockPieceIn();\r\n          } else {\r\n            piece.y += 1;\r\n          }\r\n          break;\r\n        case 'a':\r\n          piece.angle = (piece.angle + 1) % 4;\r\n          break;\r\n        case 'b':\r\n          piece.angle = (piece.angle - 1);\r\n          if (piece.angle < 0) piece.angle = 3;\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  } else if (event[0] === \"clear\") {\r\n  }\r\n  console.log(piece);\r\n  console.log(piece && getPieceGridCoords(piece, grid));\r\n}\r\n\r\nlet start;\r\nlet dotX = 0;\r\nconst speed = 2 / 30 / 32;\r\nlet fps;\r\n\r\nfunction update(t) {\r\n  while (events.length) {\r\n    let event = events.shift();\r\n    processEvent(event);\r\n  }\r\n  fps = updateFps(t) || fps;\r\n  dotX = wrapX(dotX + speed * t);\r\n\r\n  shock = Math.max(0, shock - shockDecay * t);\r\n\r\n  grid2 = grid.map((line) => line.slice());\r\n  if (piece) {\r\n    const pieceCoords = getPieceGridCoords(piece, grid);\r\n    pieceCoords.forEach(([x, y]) => {\r\n      if (y < 0) return;\r\n      if (grid2[y]) grid2[y][x] = 2;\r\n    });\r\n  } else if (clearing) {\r\n    // animating\r\n    console.log(\"clearing animation...\", clearing);\r\n    if (timestamp() - clearing.at >= 500) {\r\n      removeLines(clearing.lines, grid);\r\n      grid2 = grid;\r\n      clearing = null;\r\n    }\r\n  } else {\r\n    const completeLines = [];\r\n    grid2.forEach((line, y) => {\r\n      if (line.find((block) => block === 0) === undefined) {\r\n        completeLines.push(y);\r\n        grid[y].fill(3);\r\n      }\r\n    });\r\n    if (completeLines.length) {\r\n      clearing = {\r\n        lines: completeLines,\r\n        at: timestamp(),\r\n      };\r\n    } else {\r\n      piece = spawn();\r\n    }\r\n  }\r\n}\r\n\r\nfunction render() {\r\n  renderGrid(grid2);\r\n  renderFps(ctx, fps);\r\n}\r\n\r\nfunction timestamp() {\r\n  return window.performance && window.performance.now\r\n    ? window.performance.now()\r\n    : Date.now();\r\n}\r\n\r\nlet last = timestamp();\r\n\r\nfunction step() {\r\n  let now = timestamp();\r\n  if (start === undefined) start = now;\r\n  const elapsed = now - start;\r\n  let dt = Math.min(1000, now - last);\r\n  update(dt);\r\n  render();\r\n  last = now;\r\n  window.requestAnimationFrame(step);\r\n}\r\n\r\nwindow.requestAnimationFrame(step);\r\n\r\nfunction init() {\r\n  view.setAttribute(\"width\", SCREEN_WIDTH);\r\n  view.setAttribute(\"height\", SCREEN_HEIGHT);\r\n  ctx = view.getContext(\"2d\");\r\n  modeSelector.init();\r\n  input.init(document, events);\r\n  view.addEventListener(\"click\", getClickHandler());\r\n\r\n  piece = spawn();\r\n  console.log(getNext());\r\n  window.requestAnimationFrame(step);\r\n}\r\n\r\ninit();\r\n"]}